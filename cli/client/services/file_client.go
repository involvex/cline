// AUTO-GENERATED FILE - DO NOT MODIFY DIRECTLY
// Generated by scripts/build-go-proto.mjs

package services

import (
	"context"
	"fmt"

	cline "github.com/cline/cli/pkg/generated/cline"
	proto "github.com/cline/cli/pkg/generated/cline"
	"google.golang.org/grpc"
)

// FileClient wraps the generated FileService gRPC client
type FileClient struct {
	client proto.FileServiceClient
}

// NewFileClient creates a new FileClient
func NewFileClient(conn *grpc.ClientConn) *FileClient {
	return &FileClient{
		client: proto.NewFileServiceClient(conn),
	}
}

// CopyToClipboard retrieves the current application copyToClipboard
func (sc *FileClient) CopyToClipboard(ctx context.Context, req *cline.StringRequest) (*cline.Empty, error) {
	resp, err := sc.client.CopyToClipboard(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to get latest copyToClipboard: %w", err)
	}

	return resp, nil
}

// OpenFile retrieves the current application openFile
func (sc *FileClient) OpenFile(ctx context.Context, req *cline.StringRequest) (*cline.Empty, error) {
	resp, err := sc.client.OpenFile(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to get latest openFile: %w", err)
	}

	return resp, nil
}

// OpenImage retrieves the current application openImage
func (sc *FileClient) OpenImage(ctx context.Context, req *cline.StringRequest) (*cline.Empty, error) {
	resp, err := sc.client.OpenImage(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to get latest openImage: %w", err)
	}

	return resp, nil
}

// OpenMention retrieves the current application openMention
func (sc *FileClient) OpenMention(ctx context.Context, req *cline.StringRequest) (*cline.Empty, error) {
	resp, err := sc.client.OpenMention(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to get latest openMention: %w", err)
	}

	return resp, nil
}

// DeleteRuleFile retrieves the current application deleteRuleFile
func (sc *FileClient) DeleteRuleFile(ctx context.Context, req *proto.RuleFileRequest) (*proto.RuleFile, error) {
	resp, err := sc.client.DeleteRuleFile(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to get latest deleteRuleFile: %w", err)
	}

	return resp, nil
}

// CreateRuleFile retrieves the current application createRuleFile
func (sc *FileClient) CreateRuleFile(ctx context.Context, req *proto.RuleFileRequest) (*proto.RuleFile, error) {
	resp, err := sc.client.CreateRuleFile(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to get latest createRuleFile: %w", err)
	}

	return resp, nil
}

// SearchCommits retrieves the current application searchCommits
func (sc *FileClient) SearchCommits(ctx context.Context, req *cline.StringRequest) (*proto.GitCommits, error) {
	resp, err := sc.client.SearchCommits(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to get latest searchCommits: %w", err)
	}

	return resp, nil
}

// SelectFiles retrieves the current application selectFiles
func (sc *FileClient) SelectFiles(ctx context.Context, req *proto.BooleanRequest) (*proto.StringArrays, error) {
	resp, err := sc.client.SelectFiles(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to get latest selectFiles: %w", err)
	}

	return resp, nil
}

// GetRelativePaths retrieves the current application getRelativePaths
func (sc *FileClient) GetRelativePaths(ctx context.Context, req *proto.RelativePathsRequest) (*proto.RelativePaths, error) {
	resp, err := sc.client.GetRelativePaths(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to get latest getRelativePaths: %w", err)
	}

	return resp, nil
}

// SearchFiles retrieves the current application searchFiles
func (sc *FileClient) SearchFiles(ctx context.Context, req *proto.FileSearchRequest) (*proto.FileSearchResults, error) {
	resp, err := sc.client.SearchFiles(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to get latest searchFiles: %w", err)
	}

	return resp, nil
}

// ToggleClineRule retrieves the current application toggleClineRule
func (sc *FileClient) ToggleClineRule(ctx context.Context, req *proto.ToggleClineRuleRequest) (*proto.ToggleClineRules, error) {
	resp, err := sc.client.ToggleClineRule(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to get latest toggleClineRule: %w", err)
	}

	return resp, nil
}

// ToggleCursorRule retrieves the current application toggleCursorRule
func (sc *FileClient) ToggleCursorRule(ctx context.Context, req *proto.ToggleCursorRuleRequest) (*proto.ClineRulesToggles, error) {
	resp, err := sc.client.ToggleCursorRule(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to get latest toggleCursorRule: %w", err)
	}

	return resp, nil
}

// ToggleWindsurfRule retrieves the current application toggleWindsurfRule
func (sc *FileClient) ToggleWindsurfRule(ctx context.Context, req *proto.ToggleWindsurfRuleRequest) (*proto.ClineRulesToggles, error) {
	resp, err := sc.client.ToggleWindsurfRule(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to get latest toggleWindsurfRule: %w", err)
	}

	return resp, nil
}

// RefreshRules retrieves the current application refreshRules
func (sc *FileClient) RefreshRules(ctx context.Context, req *cline.EmptyRequest) (*proto.RefreshedRules, error) {
	resp, err := sc.client.RefreshRules(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to get latest refreshRules: %w", err)
	}

	return resp, nil
}

// OpenDiskConversationHistory retrieves the current application openDiskConversationHistory
func (sc *FileClient) OpenDiskConversationHistory(ctx context.Context, req *cline.StringRequest) (*cline.Empty, error) {
	resp, err := sc.client.OpenDiskConversationHistory(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to get latest openDiskConversationHistory: %w", err)
	}

	return resp, nil
}

// ToggleWorkflow retrieves the current application toggleWorkflow
func (sc *FileClient) ToggleWorkflow(ctx context.Context, req *proto.ToggleWorkflowRequest) (*proto.ClineRulesToggles, error) {
	resp, err := sc.client.ToggleWorkflow(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to get latest toggleWorkflow: %w", err)
	}

	return resp, nil
}

// IfFileExistsRelativePath retrieves the current application ifFileExistsRelativePath
func (sc *FileClient) IfFileExistsRelativePath(ctx context.Context, req *cline.StringRequest) (*proto.BooleanResponse, error) {
	resp, err := sc.client.IfFileExistsRelativePath(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to get latest ifFileExistsRelativePath: %w", err)
	}

	return resp, nil
}

// OpenFileRelativePath retrieves the current application openFileRelativePath
func (sc *FileClient) OpenFileRelativePath(ctx context.Context, req *cline.StringRequest) (*cline.Empty, error) {
	resp, err := sc.client.OpenFileRelativePath(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to get latest openFileRelativePath: %w", err)
	}

	return resp, nil
}

// OpenFocusChainFile retrieves the current application openFocusChainFile
func (sc *FileClient) OpenFocusChainFile(ctx context.Context, req *cline.StringRequest) (*cline.Empty, error) {
	resp, err := sc.client.OpenFocusChainFile(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to get latest openFocusChainFile: %w", err)
	}

	return resp, nil
}
