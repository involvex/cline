// AUTO-GENERATED FILE - DO NOT MODIFY DIRECTLY
// Generated by scripts/build-go-proto.mjs

package services

import (
	"context"
	"fmt"

	cline "github.com/cline/cli/pkg/generated/cline"
	proto "github.com/cline/cli/pkg/generated/cline"
	"google.golang.org/grpc"
)

// McpClient wraps the generated McpService gRPC client
type McpClient struct {
	client proto.McpServiceClient
}

// NewMcpClient creates a new McpClient
func NewMcpClient(conn *grpc.ClientConn) *McpClient {
	return &McpClient{
		client: proto.NewMcpServiceClient(conn),
	}
}

// ToggleMcpServer retrieves the current application toggleMcpServer
func (sc *McpClient) ToggleMcpServer(ctx context.Context, req *proto.ToggleMcpServerRequest) (*proto.McpServers, error) {
	resp, err := sc.client.ToggleMcpServer(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to get latest toggleMcpServer: %w", err)
	}

	return resp, nil
}

// UpdateMcpTimeout retrieves the current application updateMcpTimeout
func (sc *McpClient) UpdateMcpTimeout(ctx context.Context, req *proto.UpdateMcpTimeoutRequest) (*proto.McpServers, error) {
	resp, err := sc.client.UpdateMcpTimeout(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to get latest updateMcpTimeout: %w", err)
	}

	return resp, nil
}

// AddRemoteMcpServer retrieves the current application addRemoteMcpServer
func (sc *McpClient) AddRemoteMcpServer(ctx context.Context, req *proto.AddRemoteMcpServerRequest) (*proto.McpServers, error) {
	resp, err := sc.client.AddRemoteMcpServer(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to get latest addRemoteMcpServer: %w", err)
	}

	return resp, nil
}

// DownloadMcp retrieves the current application downloadMcp
func (sc *McpClient) DownloadMcp(ctx context.Context, req *cline.StringRequest) (*proto.McpDownloadResponse, error) {
	resp, err := sc.client.DownloadMcp(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to get latest downloadMcp: %w", err)
	}

	return resp, nil
}

// RestartMcpServer retrieves the current application restartMcpServer
func (sc *McpClient) RestartMcpServer(ctx context.Context, req *cline.StringRequest) (*proto.McpServers, error) {
	resp, err := sc.client.RestartMcpServer(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to get latest restartMcpServer: %w", err)
	}

	return resp, nil
}

// DeleteMcpServer retrieves the current application deleteMcpServer
func (sc *McpClient) DeleteMcpServer(ctx context.Context, req *cline.StringRequest) (*proto.McpServers, error) {
	resp, err := sc.client.DeleteMcpServer(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to get latest deleteMcpServer: %w", err)
	}

	return resp, nil
}

// ToggleToolAutoApprove retrieves the current application toggleToolAutoApprove
func (sc *McpClient) ToggleToolAutoApprove(ctx context.Context, req *proto.ToggleToolAutoApproveRequest) (*proto.McpServers, error) {
	resp, err := sc.client.ToggleToolAutoApprove(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to get latest toggleToolAutoApprove: %w", err)
	}

	return resp, nil
}

// RefreshMcpMarketplace retrieves the current application refreshMcpMarketplace
func (sc *McpClient) RefreshMcpMarketplace(ctx context.Context, req *cline.EmptyRequest) (*proto.McpMarketplaceCatalog, error) {
	resp, err := sc.client.RefreshMcpMarketplace(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to get latest refreshMcpMarketplace: %w", err)
	}

	return resp, nil
}

// OpenMcpSettings retrieves the current application openMcpSettings
func (sc *McpClient) OpenMcpSettings(ctx context.Context, req *cline.EmptyRequest) (*cline.Empty, error) {
	resp, err := sc.client.OpenMcpSettings(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to get latest openMcpSettings: %w", err)
	}

	return resp, nil
}

// SubscribeToMcpMarketplaceCatalog subscribes to subscribeToMcpMarketplaceCatalog updates and returns a stream
func (sc *McpClient) SubscribeToMcpMarketplaceCatalog(ctx context.Context, req *cline.EmptyRequest) (proto.McpService_SubscribeToMcpMarketplaceCatalogClient, error) {
	stream, err := sc.client.SubscribeToMcpMarketplaceCatalog(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to subscribe to subscribeToMcpMarketplaceCatalog: %w", err)
	}

	return stream, nil
}

// GetLatestMcpServers retrieves the current application getLatestMcpServers
func (sc *McpClient) GetLatestMcpServers(ctx context.Context, req *cline.Empty) (*proto.McpServers, error) {
	resp, err := sc.client.GetLatestMcpServers(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to get latest getLatestMcpServers: %w", err)
	}

	return resp, nil
}

// SubscribeToMcpServers subscribes to subscribeToMcpServers updates and returns a stream
func (sc *McpClient) SubscribeToMcpServers(ctx context.Context, req *cline.EmptyRequest) (proto.McpService_SubscribeToMcpServersClient, error) {
	stream, err := sc.client.SubscribeToMcpServers(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to subscribe to subscribeToMcpServers: %w", err)
	}

	return stream, nil
}
