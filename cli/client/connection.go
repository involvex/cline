// AUTO-GENERATED FILE - DO NOT MODIFY DIRECTLY
// Generated by scripts/build-go-proto.mjs

package client

import (
	"context"
	"fmt"
	"sync"
	"time"

	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
)

// ConnectionConfig holds configuration for gRPC connection
type ConnectionConfig struct {
	Address string
	Timeout time.Duration
}

// ConnectionManager manages gRPC connections
type ConnectionManager struct {
	config *ConnectionConfig
	conn   *grpc.ClientConn
	mutex  sync.RWMutex
}

// NewConnectionManager creates a new connection manager
func NewConnectionManager(config *ConnectionConfig) *ConnectionManager {
	if config.Timeout == 0 {
		config.Timeout = 30 * time.Second
	}

	return &ConnectionManager{
		config: config,
	}
}

// Connect establishes a gRPC connection
func (cm *ConnectionManager) Connect(ctx context.Context) error {
	cm.mutex.Lock()
	defer cm.mutex.Unlock()

	if cm.conn != nil {
		return nil // Already connected
	}

	// Create context with timeout
	connectCtx, cancel := context.WithTimeout(ctx, cm.config.Timeout)
	defer cancel()

	// Establish gRPC connection
	conn, err := grpc.DialContext(connectCtx, cm.config.Address,
		grpc.WithTransportCredentials(insecure.NewCredentials()),
		grpc.WithBlock(),
	)
	if err != nil {
		return fmt.Errorf("failed to connect to %s: %w", cm.config.Address, err)
	}

	cm.conn = conn
	return nil
}

// Disconnect closes the gRPC connection
func (cm *ConnectionManager) Disconnect() error {
	cm.mutex.Lock()
	defer cm.mutex.Unlock()

	if cm.conn == nil {
		return nil // Already disconnected
	}

	err := cm.conn.Close()
	cm.conn = nil
	return err
}

// GetConnection returns the current gRPC connection
func (cm *ConnectionManager) GetConnection() *grpc.ClientConn {
	cm.mutex.RLock()
	defer cm.mutex.RUnlock()
	return cm.conn
}

// IsConnected returns true if connected
func (cm *ConnectionManager) IsConnected() bool {
	cm.mutex.RLock()
	defer cm.mutex.RUnlock()
	return cm.conn != nil
}
