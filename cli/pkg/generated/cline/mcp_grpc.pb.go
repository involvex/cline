// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.19.1
// source: cline/mcp.proto

package cline

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	McpService_ToggleMcpServer_FullMethodName                  = "/cline.McpService/toggleMcpServer"
	McpService_UpdateMcpTimeout_FullMethodName                 = "/cline.McpService/updateMcpTimeout"
	McpService_AddRemoteMcpServer_FullMethodName               = "/cline.McpService/addRemoteMcpServer"
	McpService_DownloadMcp_FullMethodName                      = "/cline.McpService/downloadMcp"
	McpService_RestartMcpServer_FullMethodName                 = "/cline.McpService/restartMcpServer"
	McpService_DeleteMcpServer_FullMethodName                  = "/cline.McpService/deleteMcpServer"
	McpService_ToggleToolAutoApprove_FullMethodName            = "/cline.McpService/toggleToolAutoApprove"
	McpService_RefreshMcpMarketplace_FullMethodName            = "/cline.McpService/refreshMcpMarketplace"
	McpService_OpenMcpSettings_FullMethodName                  = "/cline.McpService/openMcpSettings"
	McpService_SubscribeToMcpMarketplaceCatalog_FullMethodName = "/cline.McpService/subscribeToMcpMarketplaceCatalog"
	McpService_GetLatestMcpServers_FullMethodName              = "/cline.McpService/getLatestMcpServers"
	McpService_SubscribeToMcpServers_FullMethodName            = "/cline.McpService/subscribeToMcpServers"
)

// McpServiceClient is the client API for McpService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type McpServiceClient interface {
	ToggleMcpServer(ctx context.Context, in *ToggleMcpServerRequest, opts ...grpc.CallOption) (*McpServers, error)
	UpdateMcpTimeout(ctx context.Context, in *UpdateMcpTimeoutRequest, opts ...grpc.CallOption) (*McpServers, error)
	AddRemoteMcpServer(ctx context.Context, in *AddRemoteMcpServerRequest, opts ...grpc.CallOption) (*McpServers, error)
	DownloadMcp(ctx context.Context, in *StringRequest, opts ...grpc.CallOption) (*McpDownloadResponse, error)
	RestartMcpServer(ctx context.Context, in *StringRequest, opts ...grpc.CallOption) (*McpServers, error)
	DeleteMcpServer(ctx context.Context, in *StringRequest, opts ...grpc.CallOption) (*McpServers, error)
	ToggleToolAutoApprove(ctx context.Context, in *ToggleToolAutoApproveRequest, opts ...grpc.CallOption) (*McpServers, error)
	RefreshMcpMarketplace(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*McpMarketplaceCatalog, error)
	OpenMcpSettings(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*Empty, error)
	// Subscribe to MCP marketplace catalog updates
	SubscribeToMcpMarketplaceCatalog(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[McpMarketplaceCatalog], error)
	GetLatestMcpServers(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*McpServers, error)
	// Subscribe to MCP server updates
	SubscribeToMcpServers(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[McpServers], error)
}

type mcpServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMcpServiceClient(cc grpc.ClientConnInterface) McpServiceClient {
	return &mcpServiceClient{cc}
}

func (c *mcpServiceClient) ToggleMcpServer(ctx context.Context, in *ToggleMcpServerRequest, opts ...grpc.CallOption) (*McpServers, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(McpServers)
	err := c.cc.Invoke(ctx, McpService_ToggleMcpServer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mcpServiceClient) UpdateMcpTimeout(ctx context.Context, in *UpdateMcpTimeoutRequest, opts ...grpc.CallOption) (*McpServers, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(McpServers)
	err := c.cc.Invoke(ctx, McpService_UpdateMcpTimeout_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mcpServiceClient) AddRemoteMcpServer(ctx context.Context, in *AddRemoteMcpServerRequest, opts ...grpc.CallOption) (*McpServers, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(McpServers)
	err := c.cc.Invoke(ctx, McpService_AddRemoteMcpServer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mcpServiceClient) DownloadMcp(ctx context.Context, in *StringRequest, opts ...grpc.CallOption) (*McpDownloadResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(McpDownloadResponse)
	err := c.cc.Invoke(ctx, McpService_DownloadMcp_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mcpServiceClient) RestartMcpServer(ctx context.Context, in *StringRequest, opts ...grpc.CallOption) (*McpServers, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(McpServers)
	err := c.cc.Invoke(ctx, McpService_RestartMcpServer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mcpServiceClient) DeleteMcpServer(ctx context.Context, in *StringRequest, opts ...grpc.CallOption) (*McpServers, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(McpServers)
	err := c.cc.Invoke(ctx, McpService_DeleteMcpServer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mcpServiceClient) ToggleToolAutoApprove(ctx context.Context, in *ToggleToolAutoApproveRequest, opts ...grpc.CallOption) (*McpServers, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(McpServers)
	err := c.cc.Invoke(ctx, McpService_ToggleToolAutoApprove_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mcpServiceClient) RefreshMcpMarketplace(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*McpMarketplaceCatalog, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(McpMarketplaceCatalog)
	err := c.cc.Invoke(ctx, McpService_RefreshMcpMarketplace_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mcpServiceClient) OpenMcpSettings(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, McpService_OpenMcpSettings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mcpServiceClient) SubscribeToMcpMarketplaceCatalog(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[McpMarketplaceCatalog], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &McpService_ServiceDesc.Streams[0], McpService_SubscribeToMcpMarketplaceCatalog_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[EmptyRequest, McpMarketplaceCatalog]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type McpService_SubscribeToMcpMarketplaceCatalogClient = grpc.ServerStreamingClient[McpMarketplaceCatalog]

func (c *mcpServiceClient) GetLatestMcpServers(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*McpServers, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(McpServers)
	err := c.cc.Invoke(ctx, McpService_GetLatestMcpServers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mcpServiceClient) SubscribeToMcpServers(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[McpServers], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &McpService_ServiceDesc.Streams[1], McpService_SubscribeToMcpServers_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[EmptyRequest, McpServers]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type McpService_SubscribeToMcpServersClient = grpc.ServerStreamingClient[McpServers]

// McpServiceServer is the server API for McpService service.
// All implementations must embed UnimplementedMcpServiceServer
// for forward compatibility.
type McpServiceServer interface {
	ToggleMcpServer(context.Context, *ToggleMcpServerRequest) (*McpServers, error)
	UpdateMcpTimeout(context.Context, *UpdateMcpTimeoutRequest) (*McpServers, error)
	AddRemoteMcpServer(context.Context, *AddRemoteMcpServerRequest) (*McpServers, error)
	DownloadMcp(context.Context, *StringRequest) (*McpDownloadResponse, error)
	RestartMcpServer(context.Context, *StringRequest) (*McpServers, error)
	DeleteMcpServer(context.Context, *StringRequest) (*McpServers, error)
	ToggleToolAutoApprove(context.Context, *ToggleToolAutoApproveRequest) (*McpServers, error)
	RefreshMcpMarketplace(context.Context, *EmptyRequest) (*McpMarketplaceCatalog, error)
	OpenMcpSettings(context.Context, *EmptyRequest) (*Empty, error)
	// Subscribe to MCP marketplace catalog updates
	SubscribeToMcpMarketplaceCatalog(*EmptyRequest, grpc.ServerStreamingServer[McpMarketplaceCatalog]) error
	GetLatestMcpServers(context.Context, *Empty) (*McpServers, error)
	// Subscribe to MCP server updates
	SubscribeToMcpServers(*EmptyRequest, grpc.ServerStreamingServer[McpServers]) error
	mustEmbedUnimplementedMcpServiceServer()
}

// UnimplementedMcpServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMcpServiceServer struct{}

func (UnimplementedMcpServiceServer) ToggleMcpServer(context.Context, *ToggleMcpServerRequest) (*McpServers, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ToggleMcpServer not implemented")
}
func (UnimplementedMcpServiceServer) UpdateMcpTimeout(context.Context, *UpdateMcpTimeoutRequest) (*McpServers, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMcpTimeout not implemented")
}
func (UnimplementedMcpServiceServer) AddRemoteMcpServer(context.Context, *AddRemoteMcpServerRequest) (*McpServers, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddRemoteMcpServer not implemented")
}
func (UnimplementedMcpServiceServer) DownloadMcp(context.Context, *StringRequest) (*McpDownloadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DownloadMcp not implemented")
}
func (UnimplementedMcpServiceServer) RestartMcpServer(context.Context, *StringRequest) (*McpServers, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RestartMcpServer not implemented")
}
func (UnimplementedMcpServiceServer) DeleteMcpServer(context.Context, *StringRequest) (*McpServers, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteMcpServer not implemented")
}
func (UnimplementedMcpServiceServer) ToggleToolAutoApprove(context.Context, *ToggleToolAutoApproveRequest) (*McpServers, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ToggleToolAutoApprove not implemented")
}
func (UnimplementedMcpServiceServer) RefreshMcpMarketplace(context.Context, *EmptyRequest) (*McpMarketplaceCatalog, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RefreshMcpMarketplace not implemented")
}
func (UnimplementedMcpServiceServer) OpenMcpSettings(context.Context, *EmptyRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OpenMcpSettings not implemented")
}
func (UnimplementedMcpServiceServer) SubscribeToMcpMarketplaceCatalog(*EmptyRequest, grpc.ServerStreamingServer[McpMarketplaceCatalog]) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeToMcpMarketplaceCatalog not implemented")
}
func (UnimplementedMcpServiceServer) GetLatestMcpServers(context.Context, *Empty) (*McpServers, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLatestMcpServers not implemented")
}
func (UnimplementedMcpServiceServer) SubscribeToMcpServers(*EmptyRequest, grpc.ServerStreamingServer[McpServers]) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeToMcpServers not implemented")
}
func (UnimplementedMcpServiceServer) mustEmbedUnimplementedMcpServiceServer() {}
func (UnimplementedMcpServiceServer) testEmbeddedByValue()                    {}

// UnsafeMcpServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to McpServiceServer will
// result in compilation errors.
type UnsafeMcpServiceServer interface {
	mustEmbedUnimplementedMcpServiceServer()
}

func RegisterMcpServiceServer(s grpc.ServiceRegistrar, srv McpServiceServer) {
	// If the following call pancis, it indicates UnimplementedMcpServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&McpService_ServiceDesc, srv)
}

func _McpService_ToggleMcpServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ToggleMcpServerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(McpServiceServer).ToggleMcpServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: McpService_ToggleMcpServer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(McpServiceServer).ToggleMcpServer(ctx, req.(*ToggleMcpServerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _McpService_UpdateMcpTimeout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMcpTimeoutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(McpServiceServer).UpdateMcpTimeout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: McpService_UpdateMcpTimeout_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(McpServiceServer).UpdateMcpTimeout(ctx, req.(*UpdateMcpTimeoutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _McpService_AddRemoteMcpServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddRemoteMcpServerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(McpServiceServer).AddRemoteMcpServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: McpService_AddRemoteMcpServer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(McpServiceServer).AddRemoteMcpServer(ctx, req.(*AddRemoteMcpServerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _McpService_DownloadMcp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StringRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(McpServiceServer).DownloadMcp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: McpService_DownloadMcp_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(McpServiceServer).DownloadMcp(ctx, req.(*StringRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _McpService_RestartMcpServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StringRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(McpServiceServer).RestartMcpServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: McpService_RestartMcpServer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(McpServiceServer).RestartMcpServer(ctx, req.(*StringRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _McpService_DeleteMcpServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StringRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(McpServiceServer).DeleteMcpServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: McpService_DeleteMcpServer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(McpServiceServer).DeleteMcpServer(ctx, req.(*StringRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _McpService_ToggleToolAutoApprove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ToggleToolAutoApproveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(McpServiceServer).ToggleToolAutoApprove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: McpService_ToggleToolAutoApprove_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(McpServiceServer).ToggleToolAutoApprove(ctx, req.(*ToggleToolAutoApproveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _McpService_RefreshMcpMarketplace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(McpServiceServer).RefreshMcpMarketplace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: McpService_RefreshMcpMarketplace_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(McpServiceServer).RefreshMcpMarketplace(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _McpService_OpenMcpSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(McpServiceServer).OpenMcpSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: McpService_OpenMcpSettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(McpServiceServer).OpenMcpSettings(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _McpService_SubscribeToMcpMarketplaceCatalog_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(EmptyRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(McpServiceServer).SubscribeToMcpMarketplaceCatalog(m, &grpc.GenericServerStream[EmptyRequest, McpMarketplaceCatalog]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type McpService_SubscribeToMcpMarketplaceCatalogServer = grpc.ServerStreamingServer[McpMarketplaceCatalog]

func _McpService_GetLatestMcpServers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(McpServiceServer).GetLatestMcpServers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: McpService_GetLatestMcpServers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(McpServiceServer).GetLatestMcpServers(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _McpService_SubscribeToMcpServers_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(EmptyRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(McpServiceServer).SubscribeToMcpServers(m, &grpc.GenericServerStream[EmptyRequest, McpServers]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type McpService_SubscribeToMcpServersServer = grpc.ServerStreamingServer[McpServers]

// McpService_ServiceDesc is the grpc.ServiceDesc for McpService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var McpService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cline.McpService",
	HandlerType: (*McpServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "toggleMcpServer",
			Handler:    _McpService_ToggleMcpServer_Handler,
		},
		{
			MethodName: "updateMcpTimeout",
			Handler:    _McpService_UpdateMcpTimeout_Handler,
		},
		{
			MethodName: "addRemoteMcpServer",
			Handler:    _McpService_AddRemoteMcpServer_Handler,
		},
		{
			MethodName: "downloadMcp",
			Handler:    _McpService_DownloadMcp_Handler,
		},
		{
			MethodName: "restartMcpServer",
			Handler:    _McpService_RestartMcpServer_Handler,
		},
		{
			MethodName: "deleteMcpServer",
			Handler:    _McpService_DeleteMcpServer_Handler,
		},
		{
			MethodName: "toggleToolAutoApprove",
			Handler:    _McpService_ToggleToolAutoApprove_Handler,
		},
		{
			MethodName: "refreshMcpMarketplace",
			Handler:    _McpService_RefreshMcpMarketplace_Handler,
		},
		{
			MethodName: "openMcpSettings",
			Handler:    _McpService_OpenMcpSettings_Handler,
		},
		{
			MethodName: "getLatestMcpServers",
			Handler:    _McpService_GetLatestMcpServers_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "subscribeToMcpMarketplaceCatalog",
			Handler:       _McpService_SubscribeToMcpMarketplaceCatalog_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "subscribeToMcpServers",
			Handler:       _McpService_SubscribeToMcpServers_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "cline/mcp.proto",
}
