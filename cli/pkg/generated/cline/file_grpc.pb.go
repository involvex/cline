// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.19.1
// source: cline/file.proto

package cline

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	FileService_CopyToClipboard_FullMethodName             = "/cline.FileService/copyToClipboard"
	FileService_OpenFile_FullMethodName                    = "/cline.FileService/openFile"
	FileService_OpenImage_FullMethodName                   = "/cline.FileService/openImage"
	FileService_OpenMention_FullMethodName                 = "/cline.FileService/openMention"
	FileService_DeleteRuleFile_FullMethodName              = "/cline.FileService/deleteRuleFile"
	FileService_CreateRuleFile_FullMethodName              = "/cline.FileService/createRuleFile"
	FileService_SearchCommits_FullMethodName               = "/cline.FileService/searchCommits"
	FileService_SelectFiles_FullMethodName                 = "/cline.FileService/selectFiles"
	FileService_GetRelativePaths_FullMethodName            = "/cline.FileService/getRelativePaths"
	FileService_SearchFiles_FullMethodName                 = "/cline.FileService/searchFiles"
	FileService_ToggleClineRule_FullMethodName             = "/cline.FileService/toggleClineRule"
	FileService_ToggleCursorRule_FullMethodName            = "/cline.FileService/toggleCursorRule"
	FileService_ToggleWindsurfRule_FullMethodName          = "/cline.FileService/toggleWindsurfRule"
	FileService_RefreshRules_FullMethodName                = "/cline.FileService/refreshRules"
	FileService_OpenDiskConversationHistory_FullMethodName = "/cline.FileService/openDiskConversationHistory"
	FileService_ToggleWorkflow_FullMethodName              = "/cline.FileService/toggleWorkflow"
	FileService_IfFileExistsRelativePath_FullMethodName    = "/cline.FileService/ifFileExistsRelativePath"
	FileService_OpenFileRelativePath_FullMethodName        = "/cline.FileService/openFileRelativePath"
	FileService_OpenFocusChainFile_FullMethodName          = "/cline.FileService/openFocusChainFile"
)

// FileServiceClient is the client API for FileService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Service for file-related operations
type FileServiceClient interface {
	// Copies text to clipboard
	CopyToClipboard(ctx context.Context, in *StringRequest, opts ...grpc.CallOption) (*Empty, error)
	// Opens a file in the editor
	OpenFile(ctx context.Context, in *StringRequest, opts ...grpc.CallOption) (*Empty, error)
	// Opens an image in the system viewer
	OpenImage(ctx context.Context, in *StringRequest, opts ...grpc.CallOption) (*Empty, error)
	// Opens a mention (file, path, git commit, problem, terminal, or URL)
	OpenMention(ctx context.Context, in *StringRequest, opts ...grpc.CallOption) (*Empty, error)
	// Deletes a rule file from either global or workspace rules directory
	DeleteRuleFile(ctx context.Context, in *RuleFileRequest, opts ...grpc.CallOption) (*RuleFile, error)
	// Creates a rule file from either global or workspace rules directory
	CreateRuleFile(ctx context.Context, in *RuleFileRequest, opts ...grpc.CallOption) (*RuleFile, error)
	// Search git commits in the workspace
	SearchCommits(ctx context.Context, in *StringRequest, opts ...grpc.CallOption) (*GitCommits, error)
	// Select images and other files from the file system and returns as data URLs & paths respectively
	SelectFiles(ctx context.Context, in *BooleanRequest, opts ...grpc.CallOption) (*StringArrays, error)
	// Convert URIs to workspace-relative paths
	GetRelativePaths(ctx context.Context, in *RelativePathsRequest, opts ...grpc.CallOption) (*RelativePaths, error)
	// Search for files in the workspace with fuzzy matching
	SearchFiles(ctx context.Context, in *FileSearchRequest, opts ...grpc.CallOption) (*FileSearchResults, error)
	// Toggle a Cline rule (enable or disable)
	ToggleClineRule(ctx context.Context, in *ToggleClineRuleRequest, opts ...grpc.CallOption) (*ToggleClineRules, error)
	// Toggle a Cursor rule (enable or disable)
	ToggleCursorRule(ctx context.Context, in *ToggleCursorRuleRequest, opts ...grpc.CallOption) (*ClineRulesToggles, error)
	// Toggle a Windsurf rule (enable or disable)
	ToggleWindsurfRule(ctx context.Context, in *ToggleWindsurfRuleRequest, opts ...grpc.CallOption) (*ClineRulesToggles, error)
	// Refreshes all rule toggles (Cline, External, and Workflows)
	RefreshRules(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*RefreshedRules, error)
	// Opens a task's conversation history file on disk
	OpenDiskConversationHistory(ctx context.Context, in *StringRequest, opts ...grpc.CallOption) (*Empty, error)
	// Toggles a workflow on or off
	ToggleWorkflow(ctx context.Context, in *ToggleWorkflowRequest, opts ...grpc.CallOption) (*ClineRulesToggles, error)
	// Check if file exists in the project
	IfFileExistsRelativePath(ctx context.Context, in *StringRequest, opts ...grpc.CallOption) (*BooleanResponse, error)
	// Open a file in editor by a relative path
	OpenFileRelativePath(ctx context.Context, in *StringRequest, opts ...grpc.CallOption) (*Empty, error)
	// Opens or creates a focus chain checklist markdown file for editing
	OpenFocusChainFile(ctx context.Context, in *StringRequest, opts ...grpc.CallOption) (*Empty, error)
}

type fileServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFileServiceClient(cc grpc.ClientConnInterface) FileServiceClient {
	return &fileServiceClient{cc}
}

func (c *fileServiceClient) CopyToClipboard(ctx context.Context, in *StringRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, FileService_CopyToClipboard_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileServiceClient) OpenFile(ctx context.Context, in *StringRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, FileService_OpenFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileServiceClient) OpenImage(ctx context.Context, in *StringRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, FileService_OpenImage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileServiceClient) OpenMention(ctx context.Context, in *StringRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, FileService_OpenMention_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileServiceClient) DeleteRuleFile(ctx context.Context, in *RuleFileRequest, opts ...grpc.CallOption) (*RuleFile, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RuleFile)
	err := c.cc.Invoke(ctx, FileService_DeleteRuleFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileServiceClient) CreateRuleFile(ctx context.Context, in *RuleFileRequest, opts ...grpc.CallOption) (*RuleFile, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RuleFile)
	err := c.cc.Invoke(ctx, FileService_CreateRuleFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileServiceClient) SearchCommits(ctx context.Context, in *StringRequest, opts ...grpc.CallOption) (*GitCommits, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GitCommits)
	err := c.cc.Invoke(ctx, FileService_SearchCommits_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileServiceClient) SelectFiles(ctx context.Context, in *BooleanRequest, opts ...grpc.CallOption) (*StringArrays, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StringArrays)
	err := c.cc.Invoke(ctx, FileService_SelectFiles_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileServiceClient) GetRelativePaths(ctx context.Context, in *RelativePathsRequest, opts ...grpc.CallOption) (*RelativePaths, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RelativePaths)
	err := c.cc.Invoke(ctx, FileService_GetRelativePaths_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileServiceClient) SearchFiles(ctx context.Context, in *FileSearchRequest, opts ...grpc.CallOption) (*FileSearchResults, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FileSearchResults)
	err := c.cc.Invoke(ctx, FileService_SearchFiles_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileServiceClient) ToggleClineRule(ctx context.Context, in *ToggleClineRuleRequest, opts ...grpc.CallOption) (*ToggleClineRules, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ToggleClineRules)
	err := c.cc.Invoke(ctx, FileService_ToggleClineRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileServiceClient) ToggleCursorRule(ctx context.Context, in *ToggleCursorRuleRequest, opts ...grpc.CallOption) (*ClineRulesToggles, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClineRulesToggles)
	err := c.cc.Invoke(ctx, FileService_ToggleCursorRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileServiceClient) ToggleWindsurfRule(ctx context.Context, in *ToggleWindsurfRuleRequest, opts ...grpc.CallOption) (*ClineRulesToggles, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClineRulesToggles)
	err := c.cc.Invoke(ctx, FileService_ToggleWindsurfRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileServiceClient) RefreshRules(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*RefreshedRules, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RefreshedRules)
	err := c.cc.Invoke(ctx, FileService_RefreshRules_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileServiceClient) OpenDiskConversationHistory(ctx context.Context, in *StringRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, FileService_OpenDiskConversationHistory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileServiceClient) ToggleWorkflow(ctx context.Context, in *ToggleWorkflowRequest, opts ...grpc.CallOption) (*ClineRulesToggles, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClineRulesToggles)
	err := c.cc.Invoke(ctx, FileService_ToggleWorkflow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileServiceClient) IfFileExistsRelativePath(ctx context.Context, in *StringRequest, opts ...grpc.CallOption) (*BooleanResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BooleanResponse)
	err := c.cc.Invoke(ctx, FileService_IfFileExistsRelativePath_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileServiceClient) OpenFileRelativePath(ctx context.Context, in *StringRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, FileService_OpenFileRelativePath_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileServiceClient) OpenFocusChainFile(ctx context.Context, in *StringRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, FileService_OpenFocusChainFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FileServiceServer is the server API for FileService service.
// All implementations must embed UnimplementedFileServiceServer
// for forward compatibility.
//
// Service for file-related operations
type FileServiceServer interface {
	// Copies text to clipboard
	CopyToClipboard(context.Context, *StringRequest) (*Empty, error)
	// Opens a file in the editor
	OpenFile(context.Context, *StringRequest) (*Empty, error)
	// Opens an image in the system viewer
	OpenImage(context.Context, *StringRequest) (*Empty, error)
	// Opens a mention (file, path, git commit, problem, terminal, or URL)
	OpenMention(context.Context, *StringRequest) (*Empty, error)
	// Deletes a rule file from either global or workspace rules directory
	DeleteRuleFile(context.Context, *RuleFileRequest) (*RuleFile, error)
	// Creates a rule file from either global or workspace rules directory
	CreateRuleFile(context.Context, *RuleFileRequest) (*RuleFile, error)
	// Search git commits in the workspace
	SearchCommits(context.Context, *StringRequest) (*GitCommits, error)
	// Select images and other files from the file system and returns as data URLs & paths respectively
	SelectFiles(context.Context, *BooleanRequest) (*StringArrays, error)
	// Convert URIs to workspace-relative paths
	GetRelativePaths(context.Context, *RelativePathsRequest) (*RelativePaths, error)
	// Search for files in the workspace with fuzzy matching
	SearchFiles(context.Context, *FileSearchRequest) (*FileSearchResults, error)
	// Toggle a Cline rule (enable or disable)
	ToggleClineRule(context.Context, *ToggleClineRuleRequest) (*ToggleClineRules, error)
	// Toggle a Cursor rule (enable or disable)
	ToggleCursorRule(context.Context, *ToggleCursorRuleRequest) (*ClineRulesToggles, error)
	// Toggle a Windsurf rule (enable or disable)
	ToggleWindsurfRule(context.Context, *ToggleWindsurfRuleRequest) (*ClineRulesToggles, error)
	// Refreshes all rule toggles (Cline, External, and Workflows)
	RefreshRules(context.Context, *EmptyRequest) (*RefreshedRules, error)
	// Opens a task's conversation history file on disk
	OpenDiskConversationHistory(context.Context, *StringRequest) (*Empty, error)
	// Toggles a workflow on or off
	ToggleWorkflow(context.Context, *ToggleWorkflowRequest) (*ClineRulesToggles, error)
	// Check if file exists in the project
	IfFileExistsRelativePath(context.Context, *StringRequest) (*BooleanResponse, error)
	// Open a file in editor by a relative path
	OpenFileRelativePath(context.Context, *StringRequest) (*Empty, error)
	// Opens or creates a focus chain checklist markdown file for editing
	OpenFocusChainFile(context.Context, *StringRequest) (*Empty, error)
	mustEmbedUnimplementedFileServiceServer()
}

// UnimplementedFileServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFileServiceServer struct{}

func (UnimplementedFileServiceServer) CopyToClipboard(context.Context, *StringRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CopyToClipboard not implemented")
}
func (UnimplementedFileServiceServer) OpenFile(context.Context, *StringRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OpenFile not implemented")
}
func (UnimplementedFileServiceServer) OpenImage(context.Context, *StringRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OpenImage not implemented")
}
func (UnimplementedFileServiceServer) OpenMention(context.Context, *StringRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OpenMention not implemented")
}
func (UnimplementedFileServiceServer) DeleteRuleFile(context.Context, *RuleFileRequest) (*RuleFile, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRuleFile not implemented")
}
func (UnimplementedFileServiceServer) CreateRuleFile(context.Context, *RuleFileRequest) (*RuleFile, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateRuleFile not implemented")
}
func (UnimplementedFileServiceServer) SearchCommits(context.Context, *StringRequest) (*GitCommits, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchCommits not implemented")
}
func (UnimplementedFileServiceServer) SelectFiles(context.Context, *BooleanRequest) (*StringArrays, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SelectFiles not implemented")
}
func (UnimplementedFileServiceServer) GetRelativePaths(context.Context, *RelativePathsRequest) (*RelativePaths, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRelativePaths not implemented")
}
func (UnimplementedFileServiceServer) SearchFiles(context.Context, *FileSearchRequest) (*FileSearchResults, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchFiles not implemented")
}
func (UnimplementedFileServiceServer) ToggleClineRule(context.Context, *ToggleClineRuleRequest) (*ToggleClineRules, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ToggleClineRule not implemented")
}
func (UnimplementedFileServiceServer) ToggleCursorRule(context.Context, *ToggleCursorRuleRequest) (*ClineRulesToggles, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ToggleCursorRule not implemented")
}
func (UnimplementedFileServiceServer) ToggleWindsurfRule(context.Context, *ToggleWindsurfRuleRequest) (*ClineRulesToggles, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ToggleWindsurfRule not implemented")
}
func (UnimplementedFileServiceServer) RefreshRules(context.Context, *EmptyRequest) (*RefreshedRules, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RefreshRules not implemented")
}
func (UnimplementedFileServiceServer) OpenDiskConversationHistory(context.Context, *StringRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OpenDiskConversationHistory not implemented")
}
func (UnimplementedFileServiceServer) ToggleWorkflow(context.Context, *ToggleWorkflowRequest) (*ClineRulesToggles, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ToggleWorkflow not implemented")
}
func (UnimplementedFileServiceServer) IfFileExistsRelativePath(context.Context, *StringRequest) (*BooleanResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IfFileExistsRelativePath not implemented")
}
func (UnimplementedFileServiceServer) OpenFileRelativePath(context.Context, *StringRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OpenFileRelativePath not implemented")
}
func (UnimplementedFileServiceServer) OpenFocusChainFile(context.Context, *StringRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OpenFocusChainFile not implemented")
}
func (UnimplementedFileServiceServer) mustEmbedUnimplementedFileServiceServer() {}
func (UnimplementedFileServiceServer) testEmbeddedByValue()                     {}

// UnsafeFileServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FileServiceServer will
// result in compilation errors.
type UnsafeFileServiceServer interface {
	mustEmbedUnimplementedFileServiceServer()
}

func RegisterFileServiceServer(s grpc.ServiceRegistrar, srv FileServiceServer) {
	// If the following call pancis, it indicates UnimplementedFileServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&FileService_ServiceDesc, srv)
}

func _FileService_CopyToClipboard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StringRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServiceServer).CopyToClipboard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileService_CopyToClipboard_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServiceServer).CopyToClipboard(ctx, req.(*StringRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileService_OpenFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StringRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServiceServer).OpenFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileService_OpenFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServiceServer).OpenFile(ctx, req.(*StringRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileService_OpenImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StringRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServiceServer).OpenImage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileService_OpenImage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServiceServer).OpenImage(ctx, req.(*StringRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileService_OpenMention_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StringRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServiceServer).OpenMention(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileService_OpenMention_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServiceServer).OpenMention(ctx, req.(*StringRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileService_DeleteRuleFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RuleFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServiceServer).DeleteRuleFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileService_DeleteRuleFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServiceServer).DeleteRuleFile(ctx, req.(*RuleFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileService_CreateRuleFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RuleFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServiceServer).CreateRuleFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileService_CreateRuleFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServiceServer).CreateRuleFile(ctx, req.(*RuleFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileService_SearchCommits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StringRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServiceServer).SearchCommits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileService_SearchCommits_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServiceServer).SearchCommits(ctx, req.(*StringRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileService_SelectFiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BooleanRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServiceServer).SelectFiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileService_SelectFiles_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServiceServer).SelectFiles(ctx, req.(*BooleanRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileService_GetRelativePaths_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RelativePathsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServiceServer).GetRelativePaths(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileService_GetRelativePaths_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServiceServer).GetRelativePaths(ctx, req.(*RelativePathsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileService_SearchFiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileSearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServiceServer).SearchFiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileService_SearchFiles_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServiceServer).SearchFiles(ctx, req.(*FileSearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileService_ToggleClineRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ToggleClineRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServiceServer).ToggleClineRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileService_ToggleClineRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServiceServer).ToggleClineRule(ctx, req.(*ToggleClineRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileService_ToggleCursorRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ToggleCursorRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServiceServer).ToggleCursorRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileService_ToggleCursorRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServiceServer).ToggleCursorRule(ctx, req.(*ToggleCursorRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileService_ToggleWindsurfRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ToggleWindsurfRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServiceServer).ToggleWindsurfRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileService_ToggleWindsurfRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServiceServer).ToggleWindsurfRule(ctx, req.(*ToggleWindsurfRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileService_RefreshRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServiceServer).RefreshRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileService_RefreshRules_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServiceServer).RefreshRules(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileService_OpenDiskConversationHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StringRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServiceServer).OpenDiskConversationHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileService_OpenDiskConversationHistory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServiceServer).OpenDiskConversationHistory(ctx, req.(*StringRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileService_ToggleWorkflow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ToggleWorkflowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServiceServer).ToggleWorkflow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileService_ToggleWorkflow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServiceServer).ToggleWorkflow(ctx, req.(*ToggleWorkflowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileService_IfFileExistsRelativePath_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StringRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServiceServer).IfFileExistsRelativePath(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileService_IfFileExistsRelativePath_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServiceServer).IfFileExistsRelativePath(ctx, req.(*StringRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileService_OpenFileRelativePath_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StringRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServiceServer).OpenFileRelativePath(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileService_OpenFileRelativePath_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServiceServer).OpenFileRelativePath(ctx, req.(*StringRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileService_OpenFocusChainFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StringRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServiceServer).OpenFocusChainFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileService_OpenFocusChainFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServiceServer).OpenFocusChainFile(ctx, req.(*StringRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FileService_ServiceDesc is the grpc.ServiceDesc for FileService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FileService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cline.FileService",
	HandlerType: (*FileServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "copyToClipboard",
			Handler:    _FileService_CopyToClipboard_Handler,
		},
		{
			MethodName: "openFile",
			Handler:    _FileService_OpenFile_Handler,
		},
		{
			MethodName: "openImage",
			Handler:    _FileService_OpenImage_Handler,
		},
		{
			MethodName: "openMention",
			Handler:    _FileService_OpenMention_Handler,
		},
		{
			MethodName: "deleteRuleFile",
			Handler:    _FileService_DeleteRuleFile_Handler,
		},
		{
			MethodName: "createRuleFile",
			Handler:    _FileService_CreateRuleFile_Handler,
		},
		{
			MethodName: "searchCommits",
			Handler:    _FileService_SearchCommits_Handler,
		},
		{
			MethodName: "selectFiles",
			Handler:    _FileService_SelectFiles_Handler,
		},
		{
			MethodName: "getRelativePaths",
			Handler:    _FileService_GetRelativePaths_Handler,
		},
		{
			MethodName: "searchFiles",
			Handler:    _FileService_SearchFiles_Handler,
		},
		{
			MethodName: "toggleClineRule",
			Handler:    _FileService_ToggleClineRule_Handler,
		},
		{
			MethodName: "toggleCursorRule",
			Handler:    _FileService_ToggleCursorRule_Handler,
		},
		{
			MethodName: "toggleWindsurfRule",
			Handler:    _FileService_ToggleWindsurfRule_Handler,
		},
		{
			MethodName: "refreshRules",
			Handler:    _FileService_RefreshRules_Handler,
		},
		{
			MethodName: "openDiskConversationHistory",
			Handler:    _FileService_OpenDiskConversationHistory_Handler,
		},
		{
			MethodName: "toggleWorkflow",
			Handler:    _FileService_ToggleWorkflow_Handler,
		},
		{
			MethodName: "ifFileExistsRelativePath",
			Handler:    _FileService_IfFileExistsRelativePath_Handler,
		},
		{
			MethodName: "openFileRelativePath",
			Handler:    _FileService_OpenFileRelativePath_Handler,
		},
		{
			MethodName: "openFocusChainFile",
			Handler:    _FileService_OpenFocusChainFile_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cline/file.proto",
}
